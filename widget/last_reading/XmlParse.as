class XmlParse{	// Constants:	public static var CLASS_REF = XmlParse;	var werte:Array = new Array(96);	var zeitwerte:Array = new Array(96);	var value_reading;	var timeXML:XML;	var timeDayXML:XML;		//lokaler daemon	var baseURL:String = "http://localhost:3000";		// beliebiger externer daemon	// var baseURL:String = "http://192.168.1.24:3000";		public function XmlParse()	{		// constructor code		timeXML = new XML();		timeXML.ignoreWhite = true;		// constructor code		timeDayXML = new XML();		timeDayXML.ignoreWhite = true;	}	public function loadXML()	{		//trace("load");		var dhelp:Date = new Date();		timeXML.load(baseURL + "/last_reading?cachebuster=" + dhelp.getTime());	}	public function loadDayXML()	{		//trace("load");		var dhelp:Date = new Date();		timeDayXML.load(baseURL + "/last_day?cachebuster=" + dhelp.getTime());	}			//imports the last_reading from the daemon	public function parseXML(success:Boolean)	{		//trace("evaluating data.");		if (success)		{			try			{				//trace('got xml document: ' + timeXML);				// Iterate top level				for (var i = 0; i < timeXML.childNodes.length; i++)				{					var inode = timeXML.childNodes[i];					//trace("Checking inode "+inode.nodeName);										if (inode.nodeName == "current_reading")					{						// Evaluate current time. 						for (var j = 0; j < inode.childNodes.length; j++)						{							var jnode = inode.childNodes[j];							//trace("Checking jnode " + jnode.nodeName);							if (jnode.nodeName == "time")							{								//trace("Node: " + jnode);								var value_timestamp = jnode.childNodes;								//trace("value: "+value_timestamp);							}							if (jnode.nodeName == "reading")							{								//trace("Node: "+jnode);								value_reading = jnode.childNodes;								//trace("reading: "+value_reading);							}						}					}				}			}			catch (ex)			{				trace(ex.name + ":" + ex.message + ":" + ex.at + ":" + ex.text);			}		}		else		{			trace('There is an error with the data.');		}	}			//imports the last_day from the daemon	public function fetchLastDay(){	try {		//trace('got xml document: '+timeDayXML);		// Iterate top level		for (var i=0; i < timeDayXML.childNodes.length; i++) {			var inode = timeDayXML.childNodes[i];			//trace("Checking inode "+inode.nodeName);			if (inode.nodeName == "last_day") {								for (var j=0; j<inode.childNodes.length; j++) {					var jnode = inode.childNodes[j];					//trace("Checking jnode "+jnode.nodeName);					if (jnode.nodeName == "reading") {												for(var k=0; k<jnode.childNodes.length; k++){							var knode = jnode.childNodes[k];							if(knode.nodeName == "value"){								//trace(knode.childNodes);								 var help = (knode.childNodes);								 werte[j] = parseInt(help);							}							if(knode.nodeName == "time"){								zeitwerte[j] = knode.childNodes;															}						}					}				}			}		}	} catch (ex) {		trace(ex.name+":"+ex.message+":"+ex.at+":"+ex.text);		}	}	}