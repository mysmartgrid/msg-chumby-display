#!/usr/bin/env ruby
###
## 
# msg-chumby-daemon: A Ruby library for the Chumby mySmartGrid daemon
# Copyright (C) 2010 Mathias Dalheimer (md@gonium.net)
# 
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#  
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
##
###

libpath=File.join(File.dirname(__FILE__), '..', 'lib')
$:.unshift << libpath 
#puts "Using library path #{$:.join(":")}" 
require 'rubygems'
require 'msg-chumby-daemon.rb'
require 'msg-flukso-localinterface.rb'
require 'optparse'
require 'ostruct'

###
## Commandline parser
#
class Optparser
  CODES = %w[iso-2022-jp shift_jis euc-jp utf8 binary]
  CODE_ALIASES = { "jis" => "iso-2022-jp", "sjis" => "shift_jis" }
  #
  # Return a structure describing the options.
  #
  def self.parse(args)
    # The options specified on the command line will be collected in *options*.
    # We set default values here.
    options = OpenStruct.new
    options.inplace = false
    options.encoding = "utf8"
    options.verbose = false
    opts = OptionParser.new do |opts|
      opts.banner = "Usage: #{$0} [options]"
      opts.separator ""
      opts.separator "Specific options:"
     opts.on("-c", "--config FILE", "The file where the configuration lives.") do |file|
        options.config_file = file
      end
      # Boolean switch.
      opts.on("-v", "--verbose", "Run verbosely") do |v|
        options.verbose = v
      end
      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        exit
      end
    end
    opts.parse!(args)
    options
  end
end

###
## Script startup
#
options = Optparser.parse(ARGV)
$verbose = options.verbose
if options.config_file == nil
  puts "Please provide a configuration file... (-h for details)."
  exit(-1);
end
if not File.exists?(options.config_file) 
  puts " Configuration file #{options.config_file} not found - no database configuration available!"
  exit(-3);
else
  $CONFIG=YAML.load_file(options.config_file);
  puts "Using this configuration:" if $verbose
  puts "#{$CONFIG}" if $verbose
  sensor_id=$CONFIG['SENSOR_ID']
  token=$CONFIG['ACCESS_TOKEN']
  if $CONFIG['FLUKSO_LOCATION_METHOD'].upcase == "STATIC"
    host=$CONFIG['FLUKSO_HOST'];
    port=$CONFIG['FLUKSO_PORT'];
    discoveryMechanism=FluksoLocal::DiscoverStaticConfiguration.new(host, port);
    location=discoveryMechanism.getFluksoLocation();
  end
  local_id=$CONFIG['FLUKSO_LOCAL_ID']
  puts "Using Flukso at location #{location} with ID #{local_id}" if $verbose
  low_bound=$CONFIG['CONSUMPTION_LOW']
  mid_bound=$CONFIG['CONSUMPTION_MID']
  high_bound=$CONFIG['CONSUMPTION_HIGH']
  boundaries = {:low => low_bound, :mid => mid_bound, :high => high_bound}
  puts "with consumption boundaries #{boundaries}" if $verbose
end

reading_cache=MSG_Chumby::Reading_Cache.new();
#$demo_importer=MSG_Chumby::RandomReadingImporter.new(reading_cache, 400);
$demo_importer=MSG_Chumby::LastMinuteImporter.new(reading_cache, location, local_id);
$lasthour_importer=MSG_Chumby::LastHourImporter.new(reading_cache, sensor_id, token);
$lastday_importer=MSG_Chumby::LastDayImporter.new(reading_cache, sensor_id, token);
$shortterm_thread=nil;
$longterm_thread=nil;
$server=MSG_Chumby::HTTP_XML_Server.new("0.0.0.0", 3000, reading_cache, boundaries);


def startAll
  $server.start();
  $shortterm_thread=Thread.new() {
    loop do
    puts "Running short term import" 
    begin
      $demo_importer.doWork();
    rescue StandardError => e
      puts "ERROR in short-term thread: #{e}"
    end
    sleep(3);
    end
  }
  $longterm_thread=Thread.new() {
    loop do
    puts "Running long term import" 
    begin
      $lasthour_importer.doWork();
      $lastday_importer.doWork();
    rescue StandardError => e
      puts "ERROR in long-term thread: #{e}"
    end
    sleep(10);
    end
  }
  $server.join();
end

def stopAll
  $shortterm_thread.stop() unless $importer_thread.stop?;
  $longterm_thread.stop() unless $importer_thread.stop?;
  $server.stop() 
  exit;
end

trap("INT") {stopAll();}
trap("KILL") {stopAll();}
startAll();
